## 同步控制

### 重入锁 ReentrantLock
* jdk5以前 性能优于关键字synchronized 以后版本差别不大
* 手动指定何时加锁，何时释放锁
* 可反复重入的
* 中断响应
  * lock.lockInterruptibly
  * 锁申请等待限时  tryLock(long timeout, TimeUnit unit)
  * lock.isHeldByCurrentThread() 查询当前线程是否持有此锁
### 公平锁 FairLock
* 非公平锁 大多数情况下，锁的申请都是非公平的，从这个锁的等待队列随机挑选
* 公平锁 按照时间的先后顺序，保证先到先得，后到后得
* 公平锁 不会产生饥饿现象
* 维护一个有序队列，性能比较低
### Condition
* await/signal
* lock对象与Condition对象绑定
### 信号量 Semaphore
* 指定多个线程访问某一资源
* 指定信号量准入数，则同时能申请多少个许可
### 读写锁 ReadWriteLock 
* 有效地减少锁竞争，提升系统性能
### CountDownLatch
* 主线程在CountDownLatch上等待，当所有检查任务全部完成后，主线程才能继续执行
### CyclicBarrier 循环栅栏
* 多线程并发控制工具
* CyclicBarrier(int parties, Runnable barrierAction)
* barrierAction就是当计数器一次计数完成后，系统会执行的动作
### LockSupport 线程阻塞工具类 
* 线程内任意位置让线程阻塞
* park()/unpark()
* 





