# 数据存储与检索
## 数据库的核心-数据结构
### 数据库中的复杂问题
* 并发控制
* 回收磁盘空间以避免日志无限增长
* 处理错误与部分写入的记录
### 索引
> 为了高效查找数据库中特定键的值
* 索引是基于原始数据衍生的额外数据结构
* 许多数据库允许添加与删除索引，这不会影响数据的内容，而只会影响查询的性能
* 任何类型的索引通常都会减慢写入速度，因为每次写入数据时都需要更新索引
* 精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度
#### 哈希索引
> 哈希索引是基于哈希表实现，哈希表是一种key-value的数据结构
* 哈希表必须全部放入内存，当哈希变满时，继续增长代价高，并且还要避免哈希冲突
* 范围查询效率不高
  * 扫描 kitty00000 和 kitty99999 之间的所有键 —— 只能逐个在散列映射中查找每个键 
#### SSTable结构和LSM-Tree索引
##### SSTable
> 要求键值对的序列按键排序
* 即使文件大于可用内存，合并段的操作仍然是简单而高效的
* 为了在文件中找到一个特定的键，你不再需要在内存中保存所有键的索引
* 由于读请求需要扫描所请求范围内的多个key-value对，因此可以将这些记录分组为块（block），并在将其写入硬盘之前对其进行压缩
##### 内存排序
* 红黑树
* AVL树
##### 存储引擎
* 当写入时，将其添加到内存中的平衡树数据结构（例如红黑树）。这个内存树有时被称为 内存表（memtable）
* 当 内存表 大于某个阈值（通常为几兆字节）时，将其作为 SSTable 文件写入硬盘
* 收到读取请求时，首先尝试在内存表中查找对应的键，如果没有，就在最近的硬盘段中寻找，如果还没有，就在下一个次新的段中继续寻找，以此类推，直到找到目标（或为空）
* 后台周期性运行一个合并和压缩过程，以合并段文件并将已覆盖或已删除的值丢弃掉
* 如果数据库崩溃，则最近的写入（在内存表中，但尚未写入硬盘）将丢失
  * 为了避免这个问题，我们可以在硬盘上保存一个单独的日志，每个写入都会立即被追加到这个日志上
#### LSM-Tree索引
