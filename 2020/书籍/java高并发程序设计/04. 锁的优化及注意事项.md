# 锁的优化及注意事项
## 提高锁性能
* 减少锁持有的时间
  * 锁持有时间过长，导致等待线程大量增加
  * 降低锁冲突的可能性
* 减小锁粒度
  * 削弱多线程锁竞争
* 用读写分离锁来替换独占锁
  * ReadWriteLock
  * 读多写少
* 锁分离 ？
* 锁粗化
  * 如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化
  * 锁粗化-虚拟机在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步的次数
## java虚拟机对锁的优化
* 锁偏向
  * 如果一个线程获得了锁，那么锁就进入偏向模式
  * -XX:+UseBiasedLocking 开启偏向锁
  * 不适用于锁竞争激烈场合（因为每次不同的线程来请求相同的锁）
* 轻量级锁
  * 偏向锁失败，虚拟机并不会立即挂起线程，会采用轻量级锁优化
  * 简单地将对象头部作为指针指向持有锁的线程堆栈的内部，判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁
* 自旋锁
  * 当前线程暂时无法获得锁，虚拟机会让当前线程做几个空循环（自旋），经过若干次循环后，如果可以得到锁，则顺利进入临界区，否则，才会真的将线程在操作系统层面挂起
* 锁消除
  * java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁
  * 节省毫无意义的请求锁时间
  * 锁消除需要逃逸分析
  * 逃逸分析-观察某一个变量是否会跳出某一作用域
  * 逃逸分析必须在-server模式下进行，使用-XX:+DoEscapeAnalysis开启
  * -XX:++EliminateLocks开启锁消除
## ThreadLocal
* 及时回收对象 ThreadLocal.remove()
* 共享对象对于竞争的处理容易引起性能损失，应该考虑使用ThreadLocal为每个线程分配单独的对象
## 无锁
* 对并发控制而言，锁是一种悲观的策略
* 无锁是一种乐观的策略，所有的线程都可以在不停顿的状态下持续执行
* 无锁的策略使用比较交换（CAS，Compare And Swap）的技术来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止
* CAS算法
  * 包含三个参数CAS(V,E,N),其中V表示要更新的变量，E表示预期值，N表示新值
     * 当V值等于E值，才会将V的值设为N
     * 当V值不等于E值，说明其他线程做了更新，则当前线程什么都不做
     * 最后，CAS返回当前V的真实值
* AtomicInteger 
   * 自增 incrementAndGet()
* java的指针 Unsafe类
  * sun.misc.Unsafe 封装一些不安全的操作（指针）
  * 调用CAS原子指令
* AtomicReference 无锁的对象引用
  * 对普通的对象的引用，保证你在修改对象引用时的线程安全性
* AtomicStampedReference 带时间戳的对象引用
  * 对象指及时间戳都必须满足期望值，写入才会成功
* AtomicIntegerArray 数组也能无锁
  * int[]类型的封装
* AtomicIntegerFieldUpdater 
  * 让普通变量变成线程安全的需求
  * 不支持静态变量
* 无锁的Vector实现
  * LockFreeVector
  * amino并发包
* SynchronousQueue
  * transfer
  * 不仅存在竞争，而且会协助工作
## 死锁
  * 两个或者多个线程相互占用对方需要的资源，而都不进行释放，导致彼此之间相互等待对方释放资源，产生了无限制等待的现象





