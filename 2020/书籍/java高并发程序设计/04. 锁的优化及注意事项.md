# 锁的优化及注意事项
## 提高锁性能
* 减少锁持有的时间
  * 锁持有时间过长，导致等待线程大量增加
  * 降低锁冲突的可能性
* 减小锁粒度
  * 削弱多线程锁竞争
* 用读写分离锁来替换独占锁
  * ReadWriteLock
  * 读多写少
* 锁分离 ？
* 锁粗化
  * 如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化
  * 锁粗化-虚拟机在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步的次数
## java虚拟机对锁的优化
* 锁偏向
  * 如果一个线程获得了锁，那么锁就进入偏向模式
  * -XX:+UseBiasedLocking 开启偏向锁
  * 不适用于锁竞争激烈场合（因为每次不同的线程来请求相同的锁）
* 轻量级锁
  * 偏向锁失败，虚拟机并不会立即挂起线程，会采用轻量级锁优化
  * 简单地将对象头部作为指针指向持有锁的线程堆栈的内部，判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁
* 自旋锁
  * 当前线程暂时无法获得锁，虚拟机会让当前线程做几个空循环（自旋），经过若干次循环后，如果可以得到锁，则顺利进入临界区，否则，才会真的将线程在操作系统层面挂起
* 锁消除
  * java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁
  * 节省毫无意义的请求锁时间
  * 锁消除需要逃逸分析
  * 逃逸分析-观察某一个变量是否会跳出某一作用域
  * 逃逸分析必须在-server模式下进行，使用-XX:+DoEscapeAnalysis开启
  * -XX:++EliminateLocks开启锁消除
## ThreadLocal
* 及时回收对象 ThreadLocal.remove()
* 共享对象对于竞争的处理容易引起性能损失，应该考虑使用ThreadLocal为每个线程分配单独的对象
## 无锁



