# 锁的优化及注意事项
## 提高锁性能
* 减少锁持有的时间
  * 锁持有时间过长，导致等待线程大量增加
  * 降低锁冲突的可能性
* 减小锁粒度
  * 削弱多线程锁竞争
* 用读写分离锁来替换独占锁
  * ReadWriteLock
  * 读多写少
* 锁分离 ？
* 锁粗化
  * 如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化
  * 锁粗化-虚拟机在遇到一连串连续地对同一个锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步的次数
## java虚拟机对锁的优化
* 锁偏向
  * 如果一个线程获得了锁，那么锁就进入偏向模式
  * -XX:+UseBiasedLocking 开启偏向锁
  * 不适用于锁竞争激烈场合（因为每次不同的线程来请求相同的锁）
* 轻量级锁
  * 偏向锁失败，虚拟机并不会立即挂起线程，会采用轻量级锁优化
  * 简单地将对象头部作为指针指向持有锁的线程堆栈的内部，判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁
* 自旋锁

