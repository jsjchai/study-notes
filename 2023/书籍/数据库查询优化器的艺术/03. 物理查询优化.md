## 物理查询优化
### 查询优化器，在物理优化阶段，主要解决的问题
* 从可选的单表扫描方式中，挑选什么样的单表扫描方式是最优的？
* 对于两个表连接时，如何连接是最优的？
* 对于多个表连接，连接顺序有多种组合，哪种连接顺序是最优的？
* 对于多个表连接，连接顺序有多种组合，是否要对每种组合都探索？如果不全部探索，怎么找到最优的一种组合?
### 查询代价估算
* 总代价 = IO 代价 + CPU 代价
* COST = P*a_page_cpu_time + W * T
  * P为计划运行时访问的页面数，a_page_cpu_time是每个页面读取的时间花费，其乘积反映了IO花费
  * T为访问的元组数，反映了CPU花费（存储层是以页面为单位，数据以页面的形式被读入内存，每个页面上可能有多条元组，访问元组需要解析元组结构，才能把元组上的字段读出，这消耗的是CPU）。如果是索引扫描，则还会包括索引读取的花费
  * W为权重因子，表明IO到CPU的相关性，又称选择率（selectivity)
### 常用的单表扫描算法
* 顺序扫描（SeqScan)
  * 从物理存储上按照存储顺序直接读取表的数据；当无索引可用，或访问表中的大部分数据，或表的数据量很小时，使用顺序扫描效果较好
* 索引扫描（IndexScan)
  * 根据索引键读索引，找出物理元组的位置；根据从索引中找到的位置，从存储中读取数据页面；索引扫描可以将元组按排序的顺序返回；索引扫描时若选择率较低，则读数据花费的IO会显著减少；换句话说，如果选择率很高，不适宜使用索引扫描
* 只读索引扫描（IndexOnlyScan）
  * 根据索引键读索引，索引中的数据能够满足条件判断，不需要读取数据页面；比索引扫描少了读取数据的IO花费
* 行扫描（RowIdScan）
  * 用于直接定位表中的某一行。对于元组，通常为元组增加特殊的列，可以通过特殊的列计算出元组的物理位置，然后直接读取元组对应的页面，获取元组；在PostgreSQL中称为Tid扫描，此种方式是在元组头上增加名为CTID的列，用这列的值可以直接计算本条元组的物理存储位置。
* 并行表扫描（ParallelTableScan）
  * 对同一个表，并行地、通过顺序的方式获取表的数据，结果是得到一个完整的表数据
* 并行索引扫描（ParallelIndexScan）
  * 对同一个表，并行地、通过索引的方式获取表的数据，将结果合并在一起
* 组合多个索引扫描
  * 对同一个元组的组合条件（AND或者OR谓词组合的多个索引列上的多条件查询）进行多次索引扫描，然后在内存里组织一个位图，用位图描述索引扫描结果中符合索引条件的元组位置。组合多个索引（包括同一索引的多次使用）来处理单个索引扫描不能实现的情况。本质上不是单表的扫描方式，是构建在单表的多个索引扫描基础上的
### 索引
> 索引是建立在表上的，本质上是通过索引直接定位表的物理元组，加快数据获取的方式，所以索引优化的手段应该归属到物理查询优化阶段
* 对表做查询，有列对象作为过滤条件，但索引列被运算符“-”处理，查询优化器不能在执行前进行取反运算，不可利用索引扫描，只能做顺序扫描
* 对表做查询，有列对象作为过滤条件，且目标列没有超出索引列，可做只读索引扫描，这种扫描方式比单纯的索引扫描的效率更高
* 对表做查询，有索引存在，选择条件包括索引列对象，但索引列对象位于一个表达式中，参与了运算，不是“key=常量”格式，则索引不可使用，只能是顺序扫描
* 对表做查询，有索引列对象作为过滤条件，操作符是范围操作符＞或＜，可做索引扫描
* 对表做查询，有索引列对象作为过滤条件，操作符是范围操作符＜＞，不可做索引扫描
* 对表做查询，有索引列对象作为过滤条件，操作符是范围操作符BETWEEN-AND，可做索引扫描
* 聚集函数MIN/MAX用在索引列上，出现在目标列，可使用索引
#### 索引列的位置对使用索引的影响
* 索引列出现在JOIN/ON子句中，作为限制条件满足“key＜op＞常量”格式可用索引
* 索引列出现在WHERE子句中，但与子查询比较，格式上不满足“key＜op＞常量”，不可用索引
```sql
 SELECT E.e1 FROM E WHERE E.e1 IN (SELECT A.a1 FROM A) ;
```
* 索引列出现在GROUPBY子句中，不触发索引扫描(无where语句)
* WHERE子句出现索引列，且GROUPBY子句出现索引列，索引扫描被使用
* WHERE子句中出现非索引列，且GROUPBY子句出现索引列，索引扫描不被使用
* WHERE子句中出现非索引列，且GROUPBY和HAVING子句出现索引列，索引扫描被使用
* ORDERBY子句中出现索引列可使用索引扫描
* ORDERBY子句中出现非索引列不可使用索引扫描
* DISTINCT子句管辖范围内出现索引列，不可使用索引扫描(无where语句)
* DISTINCT子句管辖范围内出现索引列，因WHERE子句内使用索引列，故其可使用索引扫描
* 使用联合索引的前缀部分索引键，如“key_part_1＜op＞常量”，可触发索引的使用
* 使用部分索引键，但不是联合索引的前缀部分，如“key_part_2＜op＞常量”，不可触发索引的使用
* 使用联合索引的全部索引键，但索引键不是AND操作，不可触发索引的使用
### 两表连接算法
* 嵌套循环连接算法
* 排序归并连接算法
* Hash连接算法
  * 用连接列作为Hash的关键字，对内表进行Hash运算建立Hash表，然后对外表的每个元组的连接列用Hash函数求值，值映射到内表建立好的Hash表就可以连接了；否则，探索外表的下一个元组。这样的Hash连接算法称为简单Hash连接（Simple Hash Join，SHJ）算法
  * 如果把内表和外表划分成等大小的子表，然后对外表和内表的每个相同下标值的子表进行SHJ算法的操作，可以避免因内存小反复读入内外表的数据的问题。这样的改进算法称为优美Hash连接（Grace Hash Join，GHJ）算法
  * 结合了SHJ和GHJ算法的优点的混合Hash连接（Hybrid Hash Join，HHJ）算法。HHJ算法是把第一个子表保存到内存不刷出，如果内存很大，则子表能容纳更大量的数据，效率接近于SHJ
### 多表连接算法
* 动态规划
* 启发式方法
* 贪婪算法
* System R算法
* 遗传算法

![image](https://github.com/jsjchai/study-notes/assets/13389058/9d278ae5-6e10-437f-8869-9d7d7e21536e)

