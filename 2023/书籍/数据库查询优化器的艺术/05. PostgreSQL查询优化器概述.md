## PostgreSQL查询优化器概述
> PostgreSQL查询优化器主要的功能是完成SELECT语句的执行，在保证SELECT语句正确执行之外，还有一个重要的功能，就是使用关系代数、启发式规则、代价估算模型等不同种类的技术，提高SELECT语句执行的效率
### PostgreSQL查询执行过程
1. 语法分析阶段。将SQL查询语句经词法分析和语法分析后变换为一棵查询树（Query Tree）传给下一个阶段
2. 语义检查阶段。对SQL表达的语义进行检查
3. 查询优化阶段。对语法分析树进行优化，主要分为以下两个子阶段
   * 视图重写：在查询重写规则模块中对视图用基表进行重写
   * 集合分解为非集合操作：把集合操作分解为非集合操作。对于非集合操作，又分为SPJ优化和非SPJ优化两个子阶
     * SPJ优化
        * 生成逻辑查询执行计划阶段。优化器在查询树中查找关系，创建关系结点RelOptInfo，运用查询优化技术，如子查询优化、条件化简、等价谓词重写、外连接消除等，对查询树进行等价转换，得到逻辑查询执行计划
        * 生成物理查询执行计划阶段。优化器对RelOptInfo的各个连接对象计算代价，对存取关系的不同方法、以及对所有连接对的不同连接方法创建不同路径结点，找出代价最小的路径后创建相应的计划结点，放在RelOptInfo的pathlist字段中
     * 非SPJ优化主要是对分组、排序、聚集、去重等操作的优化
4. 查询计划执行阶段。按照传到执行器的查询执行计划进行执行
   
   ![image](https://github.com/jsjchai/study-notes/assets/13389058/ac9dd8eb-d432-4507-9bb2-eb4405e527ec)

### PostgreSQL查询优化器的架构和设计思想
1. 语法查询树
   * 查询语句（SELECT）经语法分析后得到的一个树形的结构

![image](https://github.com/jsjchai/study-notes/assets/13389058/9ddf6ab6-a7dc-4381-b1e1-f0fd8c3f8b36)

     
2. 关系
   * 关系代数中一个基本的二维表，带有元信息和数据，用以模拟现实的实体。在PostgreSQL中包括基本关系（RELOPT_BASEREL）、连接关系（RELOPT_JOINREL）和其他关系（RELOPT_OTHER_MEMBER_REL、RELOPT_DEADREL）
3. 外关系和内关系
   * PostgreSQL代码中，很多时候会出现outerrel和innerrel，如hash_inner_and_outer函数、add_paths_to_joinrel函数的入口参数中都有这两个输入参数。在“R连接S”中，R称为左关系，S称为右关系，这与外关系和内关系有对应关联之处。在做物理连接时，如果数据量小的关系作为循环的外层，数据量大的关系作为循环的内循环，则前者称为外关系，后者称为内关系。外关系又称外表，内关系又称内表。外小内大的连接方式会节约IO，降低连接代价
4. 单表访问方式（表数据的获取，物理扫描）
   * 对于单个表，如何读取表中的数据，即为单表的访问方式
     * 顺序扫描。读入表的页面，逐个访问数据页上的每条元组
     * 索引扫描。依据表上的索引，直接定位表数据的物理位置，然后读入对应的数据页面，从页面上找出元组；有的是直接读取索引页面上的数据不用扫描数据页面。PostgreSQL支持这两种索引扫描方式，前者称为索引扫描，后者称为只读索引扫描
     * TID扫描。PostgreSQL的扫描元组的方式之一，在每个元组的元组头上存有元组的物理位置信息，这些物理位置信息称为CTID（是一个三元组，包括表的oid、块号、元组的块内偏移量）。TID扫描，就是在根据CTID直接定位元组的物理页面位置读入数据页面，然后从页面上分解出元组
5. 两表间的连接方式（元组的连接、物理连接）
   * PostgreSQL代码中包括3种两表连接算法，分别是嵌套循环连接、归并连接、Hash连接。连接方式表明两个表之间如何进行连接，这是一种“物理”上的连接方式，物理含义是指表在内存中如何进行元组的连接操作
     * 嵌套循环连接。两表对应的元组都要进行连接尝试（连接，要满足连接条件，不是所有左右的元组都能成功连接）。连接是以外表的一个元组从内表中找出满足条件的元组进行连接的，然后拿出外表的下一个元组，遍历内表的每个元组，连接满足连接条件的元组，直至外表元组遍历完毕。这样的连接方式不需要对元组是否有序做出要求，算法的适应范围广，内表如有索引可用效率会更高
     * 归并连接。外表和内表的元组都进行排序，然后再进行满足连接条件的元组的连接，每个关系的元组只读取一次
     * Hash连接。外表和内表的元组对内表构造Hash表，然后遍历外表的每一个元组，求出外表元组的Hash值与内表的Hash表相匹配。适用于没有索引可用的情况（右子树没有预先定义好的索引）。
6. 多表间的连接顺序（以左深连接树、紧密树等物理连接方式得出一个连接的树状的形态，即路径
   * 多个表进行连接，其连接顺序可构成不同的形式，这表示了查询执行计划树的基本形态。通常的形态包括左深连接树、右深连接树、紧密树，分别称为left-handed、right-handed、bushy，这是多个表对象的不同连接次序导致的不同的树的形态
   * 不同的连接顺序，会生成不同大小的中间关系，这意味着CPU和IO消耗不同，所以PostgreSQL中会尝试多种连接方式，找出花费最小的路径存放到Path结构体上
7. 路径
   * 路径代表了SELECT语句的FROM和WHERE/HAVING等子句的对象（表、子查询、连接后生成的表等）和单个对象的访问方式（单表访问方式）、两个对象间的连接方式（两表间的连接方式）、多个对象间的连接顺序（多表间的连接顺序）
8. 路径排序
   * 表示某个特定的path的排序顺序。结构体的名称是PathKey。而排序是针对列或表达式（列的各种计算方式的组合）进行的，排序后的列对象有助于做连接操作，有序可以减少连接的循环次数，即减少元组的遍历次数、减少CPU的消耗
9. 多表连接搜索空间（多表连接各种可能的组合）
   * 多表连接可能因连接的顺序不同，有着不同的组合方式，进而可得到不同的连接路径（每个路径就是一个组合方式），这些组合方式构成一个空间。查询优化器需要在这个空间中找出一个代价最小的路径，然后将其作为搜索的结果以生成最优查询执行计划
10. 查询执行计划
    * 计划（Plan结构体），形式上是一棵二叉树，有左右子树两个叉，在代码中可以通过create_plan函数认识查询执行计划和最优路径的关系
    * 查询执行计划，存储了最优的路径，是路径（Path）的花费（Cost）比较之后的结果
    * 查询执行计划的形成在查询优化器中分为逻辑查询优化和物理查询优化两个主要阶段
       *  逻辑查询优化阶段在关系代数和启发式规则指导下对语法查询树进行逻辑优化
       *  物理查询优化是运用物理操作符的结果，物理操作符常是关系代数操作符（逻辑操作符）的特定实现，不同数据库对物理操作符的实现不完全相同。物理优化阶段运用了代价估算模型、多表连接算法、索引等对逻辑查询执行计划进行优化，得到查询执行计划
11. 子查询（subquery）
    * 子查询本是指DML、DQL语句中的DQL语句，可多层嵌套
    * 但在PostgreSQL中，对于“子查询”，又分解为两个概念，一是子查询，二是子链接
    * PostgreSQL中的子查询是指，在一个SELECT语句的WHERE子句或HAVING子句中嵌套另一个SELECT语句的查询
12. 子链接（sublink）
    * 类似子查询，但把查询语句嵌套在表达式中（如半连接ANY和EXISTS）
```sql
SELECT col_1
FROM tab_1 T1
WHERE T1.col_2  IN  (SELECT col_3 FROM tab_2 T2 WHERE col_3＞100);
```
13. 选择率
    * 如果一个关系的所有元组都被选择，则其选择率是100%，即为1；如果查询带有限制条件，则关系的选择率是n%（0≤n≤100）
    * 选择率代表了一个全集中的元素被选出的粒度
    * 选择率的计算，需要考虑的因素主要包括：约束表达式中的操作符和操作符作用的对象、列上索引情况、列的最大值和最小值等
    * 选择率的值越低越推荐使用索引，但是否使用索引，需要根据查询优化器的代价评估决定
14. 花费（代价）
    * 是一个操作的代价表示方式，代表了CPU和IO的消耗，形式是数值型。某种操作的求解所用的消耗，称为花费（cost）
