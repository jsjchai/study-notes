## 逻辑查询优化
> 查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句等价的变换形式，使得SQL执行更高效

### SPJ查询优化
> 传统的联机事务处理（On-line Transaction Processing，OLTP）使用基于选择（SELECT）、投影（PROJECT）、连接（JOIN）3种基本操作相结合的查询，这种查询称为SPJ查询
* 选择操作。对应的是限制条件（格式类似field＜op＞consant，field表示列对象，op是操作符，如=、＞等），优化方式是选择操作下推，目的是尽量减少连接操作前的元组数，使得中间临时关系尽量少（元组数少，连接得到的元组数就少），这样可减少IO和CPU的消耗，节约内存空间
* 投影操作。对应的SELECT查询的目的列对象，优化方式是投影操作下推，目的是尽量减少连接操作前的列数，使得中间临时关系尽量小（特别注意差别：选择操作是使元组的个数“尽量少”，投影操作是使一条元组“尽量小”），这样虽然不能减少IO（多数数据库存储方式是行存储，元组是读取的最基本单位，所以要想操作列则必须读取一行数据），但可以各减少连接后的中间关系的元组大小，节约内存空间
* 连接操作。对应的是连接条件（格式类似field_1＜op＞field_2，field_1和field_2表示不同表上的列对象，op是操作符，如=、＞等），表示两个表连接的条件
    * **多表连接中每个表被连接的顺序决定着效率**。如果一个查询语句只有一个表，则这样的语句很简单；但如果有多个表，则会涉及表之间以什么样的顺序连接效率最高效（如A、B、C三表连接，如果ABC、ACB、BCA等连接后的结果集一样，则计算哪种连接次序的效率最高，是需要考虑的问题）
    * **多表连接每个表被连接的顺序由用户语义决定**。查询语句多表连接有着不同的语义（如是笛卡儿集、内连接，还是外连接中的左外连接等），这决定着表之间的前后连接次序是不能随意更换的，否则，结果集中数据是不同的。因此，表的前后连接次序是不能随意交换的
#### 子查询优化技术
* **子查询合并（Subquery Coalescing）**。在某些条件下（语义等价：两个查询块产生同样的结果集），多个子查询能够合并成一个子查询（合并后还是子查询，以后可以通过其他技术消除子查询）。这样可以把多次表扫描、多次连接减少为单次表扫描和单次连接
```sql
## 原sql
SELECT * FROM t1 WHERE a1＜10 AND (
    EXISTS (SELECT a2 FROM t2 WHERE t2.a2＜5 AND t2.b2=1) OR
    EXISTS (SELECT a2 FROM t2 WHERE t2.a2＜5 AND t2.b2=2)
);

## 优化后 两个EXISTS子句合并为一个,条件也进行了合并
SELECT * FROM t1 WHERE a1＜10 AND (EXISTS (SELECT a2 FROM t2 WHERE t2.a2＜5 AND (t2.b2=1 OR t2.b2=2));
```
* **子查询展开（Subquery Unnesting）**。又称子查询反嵌套，又称为子查询上拉。把一些子查询置于外层的父查询中，作为连接关系与外层父查询并列，其实质是把某些子查询重写为等价的多表连接操作（展开后，子查询不存在了，外层查询变成了多表连接）。带来的好处是，有关的访问路径、连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能地减少。常见的IN/ANY/SOME/ALL/EXISTS依据情况转换为半连接（SEMI JOIN）、普通类型的子查询消除等情况属于此类
```sql
## 原sql
SELECT * FROM t1, (SELECT * FROM t2 WHERE t2.a2 ＞10) v_t2 WHERE t1.a1＜10 AND v_t2.a2＜20;
## 优化后 子查询变为了t1、t2表的连接操作,相当于把t2表从子查询中上拉了一层
SELECT * FROM t1, t2 WHERE t1.a1＜10 AND t2.a2＜20 AND t2.a2 ＞10; 
```
* 聚集子查询消除（Aggregate Subquery Elimination）。聚集函数上推，将子查询转变为一个新的不包含聚集函数的子查询，并与父查询的部分或者全部表做左外连接。通常，一些系统支持的是标量聚集子查询消除
```sql
SELECT * FROM t1 WHERE t1.a1＞(SELECT avg(t2.a2) FROM t2);
```
* 其他。利用窗口函数消除子查询的技术（Remove Subquery using Window functions，RSW）、子查询推进（Push Subquery）等技术可用于子查询的优化

### 针对非SPJ的查询优化
> 在SPJ的基础上存在GROUPBY操作的查询，这是一种较为复杂的查询
