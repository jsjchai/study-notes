## 逻辑查询优化
> 查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句等价的变换形式，使得SQL执行更高效

### SPJ查询优化
> 传统的联机事务处理（On-line Transaction Processing，OLTP）使用基于选择（SELECT）、投影（PROJECT）、连接（JOIN）3种基本操作相结合的查询，这种查询称为SPJ查询
* 选择操作。对应的是限制条件（格式类似field＜op＞consant，field表示列对象，op是操作符，如=、＞等），优化方式是选择操作下推，目的是尽量减少连接操作前的元组数，使得中间临时关系尽量少（元组数少，连接得到的元组数就少），这样可减少IO和CPU的消耗，节约内存空间
* 投影操作。对应的SELECT查询的目的列对象，优化方式是投影操作下推，目的是尽量减少连接操作前的列数，使得中间临时关系尽量小（特别注意差别：选择操作是使元组的个数“尽量少”，投影操作是使一条元组“尽量小”），这样虽然不能减少IO（多数数据库存储方式是行存储，元组是读取的最基本单位，所以要想操作列则必须读取一行数据），但可以各减少连接后的中间关系的元组大小，节约内存空间
* 连接操作。对应的是连接条件（格式类似field_1＜op＞field_2，field_1和field_2表示不同表上的列对象，op是操作符，如=、＞等），表示两个表连接的条件
    * **多表连接中每个表被连接的顺序决定着效率**。如果一个查询语句只有一个表，则这样的语句很简单；但如果有多个表，则会涉及表之间以什么样的顺序连接效率最高效（如A、B、C三表连接，如果ABC、ACB、BCA等连接后的结果集一样，则计算哪种连接次序的效率最高，是需要考虑的问题）
    * **多表连接每个表被连接的顺序由用户语义决定**。查询语句多表连接有着不同的语义（如是笛卡儿集、内连接，还是外连接中的左外连接等），这决定着表之间的前后连接次序是不能随意更换的，否则，结果集中数据是不同的。因此，表的前后连接次序是不能随意交换的
#### 子查询优化技术
* **子查询合并（Subquery Coalescing）**。在某些条件下（语义等价：两个查询块产生同样的结果集），多个子查询能够合并成一个子查询（合并后还是子查询，以后可以通过其他技术消除子查询）。这样可以把多次表扫描、多次连接减少为单次表扫描和单次连接
```sql
## 原sql
SELECT * FROM t1 WHERE a1＜10 AND (
    EXISTS (SELECT a2 FROM t2 WHERE t2.a2＜5 AND t2.b2=1) OR
    EXISTS (SELECT a2 FROM t2 WHERE t2.a2＜5 AND t2.b2=2)
);

## 优化后 两个EXISTS子句合并为一个,条件也进行了合并
SELECT * FROM t1 WHERE a1＜10 AND (EXISTS (SELECT a2 FROM t2 WHERE t2.a2＜5 AND (t2.b2=1 OR t2.b2=2));
```
* **子查询展开（Subquery Unnesting）**。又称子查询反嵌套，又称为子查询上拉。把一些子查询置于外层的父查询中，作为连接关系与外层父查询并列，其实质是把某些子查询重写为等价的多表连接操作（展开后，子查询不存在了，外层查询变成了多表连接）。带来的好处是，有关的访问路径、连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能地减少。常见的IN/ANY/SOME/ALL/EXISTS依据情况转换为半连接（SEMI JOIN）、普通类型的子查询消除等情况属于此类
```sql
## 原sql
SELECT * FROM t1, (SELECT * FROM t2 WHERE t2.a2 ＞10) v_t2 WHERE t1.a1＜10 AND v_t2.a2＜20;
## 优化后 子查询变为了t1、t2表的连接操作,相当于把t2表从子查询中上拉了一层
SELECT * FROM t1, t2 WHERE t1.a1＜10 AND t2.a2＜20 AND t2.a2 ＞10; 
```
* 聚集子查询消除（Aggregate Subquery Elimination）。聚集函数上推，将子查询转变为一个新的不包含聚集函数的子查询，并与父查询的部分或者全部表做左外连接。通常，一些系统支持的是标量聚集子查询消除
```sql
SELECT * FROM t1 WHERE t1.a1＞(SELECT avg(t2.a2) FROM t2);
```
* 其他。利用窗口函数消除子查询的技术（Remove Subquery using Window functions，RSW）、子查询推进（Push Subquery）等技术可用于子查询的优化
#### 语义优化常见的方式
* 连接消除（Join Elimination）。对一些连接操作先不必评估代价，根据已知信息（主要依据完整性约束等，但不全是依据完整性约束）能推知结果或得到一个简化的操作。例如，利用A、B两个基表做自然连接，创建一个视图V，如果在视图V上执行查询只涉及其中一个基表的信息，则对视图的查询完全可以转化为对某个基表的查询
* 连接引入（Join Introduction）。增加连接有助于原关系变小或原关系的选择率降低
* 谓词引入（Predicate Introduction）。根据完整性约束等信息引入新谓词，如引入基于索引的列，可能使得查询更快。如一个表上，有c1＜c2的列约束，c2列上存在一个索引，查询语句中的WHERE条件有c1＞200，则可以推知c2＞200，WHERE条件变更为c1＞200AND c2＞200AND c1＜c2，由此可以利用c2列上的索引，对查询语句进行优化。如果c2列上的索引的选择率很低，则优化效果会更高
* 谓词引入（Predicate Introduction）。根据完整性约束等信息引入新谓词，如引入基于索引的列，可能使得查询更快。如一个表上，有c1＜c2的列约束，c2列上存在一个索引，查询语句中的WHERE条件有c1＞200，则可以推知c2＞200，WHERE条件变更为c1＞200AND c2＞200AND c1＜c2，由此可以利用c2列上的索引，对查询语句进行优化。如果c2列上的索引的选择率很低，则优化效果会更高
* 排序优化（Order Optimizer）。ORDERBY操作通常由索引或排序（sort）完成；如果能够利用索引，则排序操作可省略。另外，结合分组等操作，考虑ORDERBY操作的优化
* 唯一性使用（Exploiting Uniqueness）。利用唯一性、索引等特点，检查是否存在不必要的DISTINCT操作，如在主键上执行DISTINCT操作，若有则可以把DISTINCT消除掉


### 针对非SPJ的查询优化
> 在SPJ的基础上存在GROUPBY操作的查询，这是一种较为复杂的查询
* GROUPBY优化
   * 对于GROUPBY的优化，可考虑分组转换技术，即对分组操作、聚集操作与连接操作的位置进行交换
* ORDERBY优化
   * 排序消除（Order By Elimination，OBYE）。优化器在生成执行计划前，将语句中没有必要的排序操作消除（如利用索引），避免在执行计划中出现排序操作或由排序导致的操作（如在索引列上排序，可以利用索引消除排序操作）
   * 排序下推（Sort push down）。把排序操作尽量下推到基表中，有序的基表进行连接后的结果符合排序的语义，这样能避免在最终的大的连接结果集上执行排序操作
* DISTICT优化
   * DISTINCT消除（Distinct Elimination）。如果表中存在主键、唯一约束、索引等，则可以消除查询语句中的DISTINCT（这种优化方式，在语义优化中也涉及，本质上是语义优化研究的范畴）
   * DISTINCT推入（Distinct Push Down）。生成含DISTINCT的反半连接查询执行计划时，先进行反半连接再进行DISTICT操作，也许先执行DISTICT操作再执行反半连接更优，这是利用连接语义上确保唯一功能特性进行DISTINCT的优化
   * DISTINCT迁移（Distinct Placement）。对连接操作的结果执行DISTINCT，可能把DISTINCT移到一个子查询中优先进行
