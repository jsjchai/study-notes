## 延迟消息
### 背景
> 很多时候，业务有“在一段时间之后，完成一个工作任务”的需求.比如: 预约挂号,患者在预约挂号成功后,需要提前一段时间提醒患者看病就诊
### 方案
#### redis key过期通知
1. 修改redis配置文件,在redis.conf文件开启notify-keyspace-events Ex
2. 配置redis监听器
```java
 @Autowired
 private RedisConnectionFactory connectionFactory;
 @Bean
 public RedisMessageListenerContainer listenerContainer(){
     RedisMessageListenerContainer listenerContainer = new RedisMessageListenerContainer();
     listenerContainer.setConnectionFactory(connectionFactory);
     return listenerContainer;
 }

@Component
@Slf4j
public class RedisMessageListener extends KeyExpirationEventMessageListener {

    /**
     * Creates new {@link MessageListener} for {@code __keyevent@*__:expired} messages.
     *
     * @param listenerContainer must not be {@literal null}.
     */
    public RedisMessageListener(RedisMessageListenerContainer listenerContainer) {
        super(listenerContainer);
    }
    
    @Override
    public void onMessage(Message message, byte[] pattern) {
        String key = new String(message.getBody(), StandardCharsets.UTF_8);
        String channel = new String(message.getChannel(), StandardCharsets.UTF_8);
        String patternStr = new String(pattern, StandardCharsets.UTF_8);
        log.info("key:{},channel:{},pattern:{}", key, channel, patternStr);
    }
}
```
3. 缺点
* 开启键通知会对 Redis 有额外的开销
* 键通知暂时 Redis 并不保证消息必达，Redis 客户端断开连接所有 Key 丢失
* 消费速度不可自控，如果一瞬间 QPS 非常高，接收到的通知会非常密集，消费不过来
* 集群环境下,需考虑单机监听

#### Redis ZSet
> Redis中的ZSet是一个有序的Set,内部使用HashMap和跳表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单,借助ZSet数据类型,以延迟时间戳作为score,把延迟任务存储在此数据集合中，然后在开启一个无限循环查询当前时间的所有任务进行消费.但是可能有并发问题，即两个线程或者两个进程都会拿到一样的数据，然后重复执行，最后又都会删除。如果是单机多线程执行，或者分布式环境下，可以使用 Redis 事务，也可以使用由 Redis 实现的分布式锁，或者使用下例中 Redis Script。你可以在 Redis 官方的 Transaction 章节找到事务的相关内容.这种方式比较推荐，可以满足持久化，分布式的场景，使用的话，Redisson 框架有封装好，直接使用即可
#### 定时任务轮训
> 配置一个定时任务,每隔一段时间轮训一次
##### 缺点
1. 因为是每隔一段时间轮训一次,存在时间差,不能够及时处理
2. 对数据库造成一定压力,造成好多无意义的扫描
3. 效率
#### 消息队列

### 参考文档
* [延迟任务场景技术选型](https://note.dolyw.com/distributed/25-Delay-Task.html)
* [6种延时队列的实现方案](https://segmentfault.com/a/1190000022718540)
